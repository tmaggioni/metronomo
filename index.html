<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Metronome</title>
  <style>
    :root {
      color-scheme: light dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f172a;
      color: #e2e8f0;
    }

    .app {
      width: min(30rem, 94vw);
      padding: 1.5rem;
      border-radius: 1rem;
      background: #111827;
      border: 1px solid #1f2937;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
    }

    h1 {
      margin: 0 0 1rem;
      font-size: 1.4rem;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.8rem;
    }

    .row label {
      min-width: 5.4rem;
      font-size: 0.9rem;
    }

    .group-title {
      margin: 1rem 0 0.65rem;
      color: #cbd5e1;
      font-size: 0.88rem;
      font-weight: 600;
    }

    .mode-list {
      display: grid;
      gap: 0.5rem;
      margin-bottom: 0.8rem;
    }

    .mode-list label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
    }

    .mode-panel {
      display: none;
      padding: 0.8rem;
      border: 1px solid #334155;
      border-radius: 0.6rem;
      margin-bottom: 0.8rem;
    }

    .mode-panel.active {
      display: block;
    }

    input[data-numeric="true"] {
      width: 100%;
      padding: 0.55rem 0.7rem;
      border-radius: 0.5rem;
      border: 1px solid #334155;
      background: #0b1220;
      color: inherit;
      font-size: 1rem;
    }

    .button-row {
      display: flex;
      gap: 0.75rem;
      margin-top: 0.8rem;
    }

    button {
      flex: 1;
      padding: 0.65rem 0.85rem;
      border: 0;
      border-radius: 0.6rem;
      color: #e2e8f0;
      background: #2563eb;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    #stop-button {
      background: #dc2626;
    }

    .status {
      margin-top: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .beat-indicator {
      width: 0.95rem;
      height: 0.95rem;
      border-radius: 999px;
      background: #475569;
      transition: transform 80ms ease, background-color 80ms ease;
    }

    .beat-indicator.active {
      transform: scale(1.5);
      background: #22c55e;
    }

    .hint {
      margin-top: 0.65rem;
      color: #94a3b8;
      font-size: 0.8rem;
    }
  </style>
</head>

<body>
  <main class="app">
    <h1>Metronome</h1>

    <div class="row">
      <label for="bpm-input">Base BPM</label>
      <input id="bpm-input" type="text" data-numeric="true" inputmode="numeric" pattern="[0-9]*" autocomplete="off"
        value="120" />
    </div>

    <p class="group-title">Speed Settings</p>
    <div class="mode-list">
      <label>
        <input type="radio" name="speed-mode" value="relative" checked />
        Relative Speed
      </label>
      <label>
        <input type="radio" name="speed-mode" value="fixed" />
        Fixed BPM
      </label>
      <label>
        <input type="radio" name="speed-mode" value="progressive" />
        Progressive Speed
      </label>
    </div>

    <section id="relative-panel" class="mode-panel active">
      <div class="row">
        <label for="relative-speed-input">Speed %</label>
        <input id="relative-speed-input" type="text" data-numeric="true" inputmode="numeric" pattern="[0-9]*"
          autocomplete="off" value="100" />
      </div>
    </section>

    <section id="fixed-panel" class="mode-panel">
      <div class="row">
        <label for="fixed-bpm-input">BPM</label>
        <input id="fixed-bpm-input" type="text" data-numeric="true" inputmode="numeric" pattern="[0-9]*"
          autocomplete="off" value="120" />
      </div>
    </section>

    <section id="progressive-panel" class="mode-panel">
      <div class="row">
        <label for="progressive-from-input">From %</label>
        <input id="progressive-from-input" type="text" data-numeric="true" inputmode="numeric" pattern="[0-9]*"
          autocomplete="off" value="50" />
      </div>
      <div class="row">
        <label for="progressive-to-input">To %</label>
        <input id="progressive-to-input" type="text" data-numeric="true" inputmode="numeric" pattern="[0-9]*"
          autocomplete="off" value="100" />
      </div>
      <div class="row">
        <label for="progressive-step-input">Step %</label>
        <input id="progressive-step-input" type="text" data-numeric="true" inputmode="numeric" pattern="[0-9]*"
          autocomplete="off" value="2" />
      </div>
      <div class="row">
        <label for="progressive-repeat-input">Repeat</label>
        <input id="progressive-repeat-input" type="text" data-numeric="true" inputmode="numeric" pattern="[0-9]*"
          autocomplete="off" value="1" />
      </div>
      <div class="row">
        <label for="step-seconds-input">Step (s)</label>
        <input id="step-seconds-input" type="text" data-numeric="true" inputmode="numeric" pattern="[0-9]*"
          autocomplete="off" value="60" />
      </div>
    </section>

    <p id="mode-display" class="hint">Mode: Relative Speed (100%)</p>

    <div class="button-row">
      <button id="start-button" type="button">Start</button>
      <button id="stop-button" type="button" disabled>Stop</button>
    </div>

    <div class="status">
      <p id="bpm-display" aria-live="polite">Current BPM: 120</p>
      <div id="beat-indicator" class="beat-indicator" aria-hidden="true"></div>
    </div>

    <p class="hint">Base BPM range: 30-300</p>
  </main>

  <script>
    const bpmInput = document.getElementById("bpm-input");
    const speedModeInputs = Array.from(document.querySelectorAll('input[name="speed-mode"]'));
    const relativePanel = document.getElementById("relative-panel");
    const fixedPanel = document.getElementById("fixed-panel");
    const progressivePanel = document.getElementById("progressive-panel");
    const relativeSpeedInput = document.getElementById("relative-speed-input");
    const fixedBpmInput = document.getElementById("fixed-bpm-input");
    const progressiveFromInput = document.getElementById("progressive-from-input");
    const progressiveToInput = document.getElementById("progressive-to-input");
    const progressiveStepInput = document.getElementById("progressive-step-input");
    const progressiveRepeatInput = document.getElementById("progressive-repeat-input");
    const stepSecondsInput = document.getElementById("step-seconds-input");
    const bpmDisplay = document.getElementById("bpm-display");
    const modeDisplay = document.getElementById("mode-display");
    const startButton = document.getElementById("start-button");
    const stopButton = document.getElementById("stop-button");
    const beatIndicator = document.getElementById("beat-indicator");
    const numericMaskedInputs = Array.from(document.querySelectorAll('input[data-numeric="true"]'));

    const MIN_BPM = 0;
    const MAX_BPM = 600;
    const MIN_PERCENT = 25;
    const MAX_PERCENT = 300;
    const MIN_STEP_SECONDS = 1;
    const MAX_STEP_SECONDS = 600;
    const MIN_STEP_PERCENT = 1;
    const MAX_STEP_PERCENT = 50;
    const MIN_REPEAT = 1;
    const MAX_REPEAT = 50;
    const PULSE_DURATION_MS = 90;

    let isPlaying = false;
    let baseBpm = 120;
    let currentBpm = 120;
    let speedMode = "relative";
    let relativeSpeedPercent = 100;
    let fixedBpm = 120;
    let progressiveFromPercent = 50;
    let progressiveToPercent = 100;
    let progressiveStepPercent = 2;
    let progressiveRepeatCount = 1;
    let progressiveStepSeconds = 60;
    let progressiveCurrentPercent = 50;
    let progressiveCyclesCompleted = 0;
    let timerId = null;
    let progressiveTimerId = null;
    let audioContext = null;

    function clampBpm(nextBpm) {
      if (Number.isNaN(nextBpm)) return currentBpm;
      if (nextBpm < MIN_BPM) return MIN_BPM;
      if (nextBpm > MAX_BPM) return MAX_BPM;
      return Math.round(nextBpm);
    }

    function clampPercent(nextPercent) {
      if (Number.isNaN(nextPercent)) return MIN_PERCENT;
      if (nextPercent < MIN_PERCENT) return MIN_PERCENT;
      if (nextPercent > MAX_PERCENT) return MAX_PERCENT;
      return Math.round(nextPercent);
    }

    function clampStepPercent(nextStepPercent) {
      if (Number.isNaN(nextStepPercent)) return progressiveStepPercent;
      if (nextStepPercent < MIN_STEP_PERCENT) return MIN_STEP_PERCENT;
      if (nextStepPercent > MAX_STEP_PERCENT) return MAX_STEP_PERCENT;
      return Math.round(nextStepPercent);
    }

    function clampStepSeconds(nextStepSeconds) {
      if (Number.isNaN(nextStepSeconds)) return progressiveStepSeconds;
      if (nextStepSeconds < MIN_STEP_SECONDS) return MIN_STEP_SECONDS;
      if (nextStepSeconds > MAX_STEP_SECONDS) return MAX_STEP_SECONDS;
      return Math.round(nextStepSeconds);
    }

    function clampRepeat(nextRepeat) {
      if (Number.isNaN(nextRepeat)) return progressiveRepeatCount;
      if (nextRepeat < MIN_REPEAT) return MIN_REPEAT;
      if (nextRepeat > MAX_REPEAT) return MAX_REPEAT;
      return Math.round(nextRepeat);
    }

    function calculateBpmFromPercent(percent) {
      return clampBpm(Math.round((baseBpm * percent) / 100));
    }

    function applyNumericMask(value) {
      return value.replace(/\D+/g, "");
    }

    function hasInputValue(input) {
      return input.value.trim() !== "";
    }

    function setPlayingState(nextIsPlaying) {
      isPlaying = nextIsPlaying;
      startButton.disabled = nextIsPlaying;
      stopButton.disabled = !nextIsPlaying;
    }

    function updateBpmDisplay() {
      bpmDisplay.textContent = `Current BPM: ${currentBpm}`;
    }

    function updateModePanels() {
      relativePanel.classList.toggle("active", speedMode === "relative");
      fixedPanel.classList.toggle("active", speedMode === "fixed");
      progressivePanel.classList.toggle("active", speedMode === "progressive");
    }

    function updateModeDisplay() {
      if (speedMode === "relative") {
        modeDisplay.textContent = `Mode: Relative Speed (${relativeSpeedPercent}%)`;
        return;
      }

      if (speedMode === "fixed") {
        modeDisplay.textContent = `Mode: Fixed BPM (${fixedBpm})`;
        return;
      }

      modeDisplay.textContent = `Mode: Progressive (${progressiveFromPercent}% â†’ ${progressiveToPercent}%, step ${progressiveStepPercent}%, repeat ${progressiveRepeatCount}x, every ${progressiveStepSeconds}s)`;
    }

    function refreshCurrentBpmFromMode() {
      if (speedMode === "relative") currentBpm = calculateBpmFromPercent(relativeSpeedPercent);
      else if (speedMode === "fixed") currentBpm = fixedBpm;
      else currentBpm = calculateBpmFromPercent(progressiveCurrentPercent);
      updateBpmDisplay();
    }

    function applyBaseBpmFromInput(options = {}) {
      const { normalize = true } = options;
      const parsedValue = Number.parseInt(bpmInput.value, 10);
      if (Number.isNaN(parsedValue)) {
        if (normalize) bpmInput.value = String(baseBpm);
        return;
      }

      baseBpm = clampBpm(parsedValue);
      if (normalize) bpmInput.value = String(baseBpm);
      refreshCurrentBpmFromMode();
    }

    function normalizeProgressiveBounds() {
      if (progressiveFromPercent <= progressiveToPercent) return;
      progressiveToPercent = progressiveFromPercent;
    }

    function stopProgressiveTimer() {
      if (progressiveTimerId === null) return;
      window.clearInterval(progressiveTimerId);
      progressiveTimerId = null;
    }

    function restartMetronomeIfNeeded() {
      if (!isPlaying) return;
      if (timerId !== null) {
        window.clearInterval(timerId);
        timerId = null;
      }
      const intervalMs = 60000 / currentBpm;
      timerId = window.setInterval(tick, intervalMs);
    }

    function advanceProgressiveStep() {
      if (progressiveCurrentPercent >= progressiveToPercent) {
        if (progressiveCyclesCompleted + 1 >= progressiveRepeatCount) {
          stopProgressiveTimer();
          return;
        }
        progressiveCyclesCompleted += 1;
        progressiveCurrentPercent = progressiveFromPercent;
      } else {
        progressiveCurrentPercent = Math.min(
          progressiveToPercent,
          progressiveCurrentPercent + progressiveStepPercent
        );
      }

      refreshCurrentBpmFromMode();
      restartMetronomeIfNeeded();
    }

    function startProgressiveTimer() {
      stopProgressiveTimer();
      progressiveTimerId = window.setInterval(advanceProgressiveStep, progressiveStepSeconds * 1000);
    }

    function applyModeSettingsFromInputs(options = {}) {
      const { normalize = true } = options;

      if (hasInputValue(relativeSpeedInput))
        relativeSpeedPercent = clampPercent(Number.parseInt(relativeSpeedInput.value, 10));
      if (hasInputValue(fixedBpmInput))
        fixedBpm = clampBpm(Number.parseInt(fixedBpmInput.value, 10));
      if (hasInputValue(progressiveFromInput))
        progressiveFromPercent = clampPercent(Number.parseInt(progressiveFromInput.value, 10));
      if (hasInputValue(progressiveToInput))
        progressiveToPercent = clampPercent(Number.parseInt(progressiveToInput.value, 10));
      if (hasInputValue(progressiveStepInput))
        progressiveStepPercent = clampStepPercent(Number.parseInt(progressiveStepInput.value, 10));
      if (hasInputValue(progressiveRepeatInput))
        progressiveRepeatCount = clampRepeat(Number.parseInt(progressiveRepeatInput.value, 10));
      if (hasInputValue(stepSecondsInput))
        progressiveStepSeconds = clampStepSeconds(Number.parseInt(stepSecondsInput.value, 10));
      normalizeProgressiveBounds();

      if (normalize) {
        relativeSpeedInput.value = String(relativeSpeedPercent);
        fixedBpmInput.value = String(fixedBpm);
        progressiveFromInput.value = String(progressiveFromPercent);
        progressiveToInput.value = String(progressiveToPercent);
        progressiveStepInput.value = String(progressiveStepPercent);
        progressiveRepeatInput.value = String(progressiveRepeatCount);
        stepSecondsInput.value = String(progressiveStepSeconds);
      }

      if (!isPlaying && speedMode === "progressive") progressiveCurrentPercent = progressiveFromPercent;
      updateModeDisplay();
      refreshCurrentBpmFromMode();

      if (isPlaying && speedMode === "progressive") startProgressiveTimer();
      if (isPlaying && speedMode !== "progressive") stopProgressiveTimer();
      restartMetronomeIfNeeded();
    }

    function ensureAudioContext() {
      if (!audioContext)
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

      if (audioContext.state === "suspended") return audioContext.resume();
      return Promise.resolve();
    }

    function pulseBeatIndicator() {
      beatIndicator.classList.add("active");
      window.setTimeout(() => {
        beatIndicator.classList.remove("active");
      }, PULSE_DURATION_MS);
    }

    function playClick() {
      if (!audioContext) return;
      const now = audioContext.currentTime;
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.type = "square";
      oscillator.frequency.setValueAtTime(1000, now);
      gainNode.gain.setValueAtTime(0.0001, now);
      gainNode.gain.exponentialRampToValueAtTime(0.25, now + 0.005);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.04);

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.start(now);
      oscillator.stop(now + 0.05);
    }

    function tick() {
      playClick();
      pulseBeatIndicator();
    }

    function startMetronome() {
      if (isPlaying) return;
      if (speedMode === "progressive") {
        progressiveCyclesCompleted = 0;
        progressiveCurrentPercent = progressiveFromPercent;
        refreshCurrentBpmFromMode();
        startProgressiveTimer();
      } else stopProgressiveTimer();

      const intervalMs = 60000 / currentBpm;
      timerId = window.setInterval(tick, intervalMs);
      tick();
      setPlayingState(true);
    }

    function stopMetronome() {
      if (timerId !== null) {
        window.clearInterval(timerId);
        timerId = null;
      }
      stopProgressiveTimer();
      progressiveCyclesCompleted = 0;
      progressiveCurrentPercent = progressiveFromPercent;
      refreshCurrentBpmFromMode();
      setPlayingState(false);
    }

    bpmInput.addEventListener("input", () => {
      if (!hasInputValue(bpmInput)) return;
      applyBaseBpmFromInput({ normalize: false });
      restartMetronomeIfNeeded();
    });
    bpmInput.addEventListener("blur", applyBaseBpmFromInput);

    speedModeInputs.forEach((input) => {
      input.addEventListener("change", () => {
        speedMode = input.value;
        updateModePanels();
        if (!isPlaying && speedMode === "progressive")
          progressiveCurrentPercent = progressiveFromPercent;
        updateModeDisplay();
        refreshCurrentBpmFromMode();
        if (isPlaying && speedMode === "progressive") startProgressiveTimer();
        if (isPlaying && speedMode !== "progressive") stopProgressiveTimer();
        restartMetronomeIfNeeded();
      });
    });

    [
      relativeSpeedInput,
      fixedBpmInput,
      progressiveFromInput,
      progressiveToInput,
      progressiveStepInput,
      progressiveRepeatInput,
      stepSecondsInput,
    ].forEach((input) => {
      input.addEventListener("input", () => {
        if (!hasInputValue(input)) return;
        applyModeSettingsFromInputs({ normalize: false });
      });
      input.addEventListener("blur", applyModeSettingsFromInputs);
    });

    startButton.addEventListener("click", async () => {
      applyBaseBpmFromInput();
      applyModeSettingsFromInputs();
      try {
        await ensureAudioContext();
        startMetronome();
      } catch (error) {
        console.error("Unable to start audio context", error);
      }
    });

    stopButton.addEventListener("click", stopMetronome);

    numericMaskedInputs.forEach((input) => {
      input.addEventListener("input", () => {
        input.value = applyNumericMask(input.value);
      });
    });

    updateModePanels();
    applyBaseBpmFromInput();
    applyModeSettingsFromInputs();
  </script>
</body>

</html>